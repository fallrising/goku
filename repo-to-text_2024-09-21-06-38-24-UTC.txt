Directory: goku-cli

Directory Structure:
```
.
├── .gitignore
├── README.md
├── bin
│   └── bin/goku
├── build.sh
│   └── cmd/goku
│       └── cmd/goku/main.go
├── docs
│   └── docs/PRD.md
├── go.mod
├── go.sum
├── init.sh
│   ├── internal/bookmarks
│   │   └── internal/bookmarks/service.go
│   ├── internal/database
│   │   └── internal/database/db.go
│   ├── internal/fetcher
│   │   └── internal/fetcher/fetcher.go
│   ├── pkg/interfaces
│   │   └── pkg/interfaces/bookmark_repository.go
│   └── pkg/models
│       └── pkg/models/bookmark.go
└── validate.sh
```

Contents of validate.sh:
```
#!/bin/bash

set -e

# Create a temporary directory for the test database
TEST_DB="./goku.db"

cleanup() {
    echo "Cleaning up..."
    rm -f "$TEST_DB"
}

# Set up trap to ensure cleanup happens even if the script fails
trap cleanup EXIT

# Build the Goku CLI using build.sh
echo "Building Goku CLI..."
if ! ./build.sh; then
    echo "Build failed. Exiting."
    exit 1
fi

# Function to run Goku CLI commands with the test database
run_goku() {
    GOKU_DB_PATH="$TEST_DB" ./bin/goku "$@"
}

echo "Starting CRUD and Search validation for Goku CLI"

# Test 1: Basic CRUD operations
echo "1. Creating a bookmark with all details provided"
CREATE_OUTPUT=$(run_goku add --url "https://example.com" --title "Example Site" --description "An example website" --tags "example,test")
echo "$CREATE_OUTPUT"
BOOKMARK_ID=$(echo "$CREATE_OUTPUT" | sed -n 's/.*ID: \([0-9]*\).*/\1/p')

if [ -z "$BOOKMARK_ID" ]; then
    echo "Failed to extract bookmark ID"
    exit 1
fi

echo "Created bookmark with ID: $BOOKMARK_ID"

# Read the bookmark
echo "2. Reading the created bookmark"
run_goku get --id "$BOOKMARK_ID"

# Update the bookmark
echo "3. Updating the bookmark"
run_goku update --id "$BOOKMARK_ID" --title "Updated Example Site" --description "An updated example website" --tags "example,test,updated"

echo "3.1 Testing partial update"
run_goku update --id "$BOOKMARK_ID" --title "Partially Updated Example Site"
PARTIAL_UPDATE_OUTPUT=$(run_goku get --id "$BOOKMARK_ID")
if ! echo "$PARTIAL_UPDATE_OUTPUT" | grep -q "Title:Partially Updated Example Site"; then
    echo "Error: Partial update of title failed"
    exit 1
fi
if ! echo "$PARTIAL_UPDATE_OUTPUT" | grep -q "Description:An updated example website"; then
    echo "Error: Partial update changed description unexpectedly"
    exit 1
fi

# Read the updated bookmark
echo "4. Reading the updated bookmark"
run_goku get --id "$BOOKMARK_ID"

# List all bookmarks
echo "5. Listing all bookmarks"
run_goku list

# Test 2: Search functionality
echo "6. Testing search functionality"

# Search by title
echo "6.1 Searching by title"
SEARCH_OUTPUT=$(run_goku search --query "Updated Example")
echo "$SEARCH_OUTPUT"
if ! echo "$SEARCH_OUTPUT" | grep -q "Updated Example Site"; then
    echo "Error: Search by title failed"
    exit 1
fi

# Search by URL
echo "6.2 Searching by URL"
SEARCH_OUTPUT=$(run_goku search --query "example.com")
echo "$SEARCH_OUTPUT"
if ! echo "$SEARCH_OUTPUT" | grep -q "https://example.com"; then
    echo "Error: Search by URL failed"
    exit 1
fi

# Search by description
echo "6.3 Searching by description"
SEARCH_OUTPUT=$(run_goku search --query "updated example")
echo "$SEARCH_OUTPUT"
if ! echo "$SEARCH_OUTPUT" | grep -q "updated example"; then
    echo "Error: Search by description failed"
    exit 1
fi

# Search by tag
echo "6.4 Searching by tag"
SEARCH_OUTPUT=$(run_goku search --query "updated")
echo "$SEARCH_OUTPUT"
if ! echo "$SEARCH_OUTPUT" | grep -q "example test updated"; then
    echo "Error: Search by tag failed"
    exit 1
fi

# Search with no results
echo "6.5 Searching with no results"
SEARCH_OUTPUT=$(run_goku search --query "nonexistent")
echo "$SEARCH_OUTPUT"
if ! echo "$SEARCH_OUTPUT" | grep -q "No bookmarks found matching the query"; then
    echo "Error: Search with no results failed"
    exit 1
fi

# Delete the bookmark
echo "7. Deleting the bookmark"
run_goku delete --id "$BOOKMARK_ID"

# Try to read the deleted bookmark (should fail)
echo "8. Attempting to read the deleted bookmark (should fail)"
if run_goku get --id "$BOOKMARK_ID" 2>/dev/null; then
    echo "Error: Bookmark was not deleted successfully"
    exit 1
else
    echo "Bookmark deleted successfully"
fi

# Test 3: Automatic webpage content extraction
echo "9. Creating a bookmark with only URL (testing automatic content extraction)"
CREATE_OUTPUT=$(run_goku add --url "https://www.example.com")
echo "$CREATE_OUTPUT"
BOOKMARK_ID=$(echo "$CREATE_OUTPUT" | sed -n 's/.*ID: \([0-9]*\).*/\1/p')

if [ -z "$BOOKMARK_ID" ]; then
    echo "Failed to extract bookmark ID"
    exit 1
fi

echo "Created bookmark with ID: $BOOKMARK_ID"

# Read the bookmark to verify automatic content extraction
echo "10. Reading the automatically extracted bookmark content"
BOOKMARK_CONTENT=$(run_goku get --id "$BOOKMARK_ID")
echo "$BOOKMARK_CONTENT"

# Verify that title was extracted (this should always be present)
if echo "$BOOKMARK_CONTENT" | grep -q "Title:Example Domain"; then
    echo "Title extraction successful"
else
    echo "Error: Title extraction failed"
    echo "Expected title 'Example Domain' not found in output:"
    echo "$BOOKMARK_CONTENT"
    exit 1
fi

# Check if description was extracted (might be empty)
if echo "$BOOKMARK_CONTENT" | grep -q "Description:"; then
    echo "Description field is present"
    DESCRIPTION=$(echo "$BOOKMARK_CONTENT" | sed -n 's/.*Description:\([^,]*\).*/\1/p' | tr -d '[:space:]')
    if [ -n "$DESCRIPTION" ]; then
        echo "Description extraction successful: $DESCRIPTION"
    else
        echo "Description is empty, but this is acceptable"
    fi
else
    echo "Error: Description field is missing"
    exit 1
fi

# Check if tags were extracted (might be empty)
if echo "$BOOKMARK_CONTENT" | grep -q "Tags:"; then
    echo "Tags field is present"
    TAGS=$(echo "$BOOKMARK_CONTENT" | sed -n 's/.*Tags:\([^]]*\).*/\1/p' | tr -d '[:space:]')
    if [ -n "$TAGS" ]; then
        echo "Tags extraction successful: $TAGS"
    else
        echo "Tags are empty, but this is acceptable"
    fi
else
    echo "Error: Tags field is missing"
    exit 1
fi

# Delete the test bookmark
echo "11. Deleting the test bookmark"
run_goku delete --id "$BOOKMARK_ID"

# List all bookmarks again (should be empty)
echo "12. Listing all bookmarks after deletion"
run_goku list

echo "13. Testing invalid input handling"
if run_goku add --url "not_a_valid_url" 2>/dev/null; then
    echo "Error: Adding invalid URL should fail"
    exit 1
fi
echo "Invalid input handling test passed"

echo "CRUD, Search, and automatic content extraction test completed successfully"

```

Contents of go.mod:
```
module github.com/fallrising/goku-cli

go 1.23.0

require (
	github.com/mattn/go-sqlite3 v1.14.23
	github.com/urfave/cli/v2 v2.27.4
	golang.org/x/net v0.29.0
)

require (
	github.com/cpuguy83/go-md2man/v2 v2.0.4 // indirect
	github.com/russross/blackfriday/v2 v2.1.0 // indirect
	github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect
)

```

Contents of init.sh:
```
#!/bin/bash

# Copyright (C) 2024 CKC All Rights Reserved.
# 
# File Name: init.sh
# Author   : CKC
# Creation Date: 2024-09-21
# INFO     :
# 
# Create subdirectories
mkdir -p cmd/goku
mkdir -p internal/{bookmarks,tags,search,import,export,database,utils,server,crawl,translate}
mkdir -p pkg/{models,interfaces}
mkdir -p scripts
mkdir -p docs
mkdir -p test/{unit,integration}
mkdir -p assets
mkdir -p config

# Create main.go file
cat << EOF > cmd/goku/main.go
package main

import (
    "fmt"
    "os"
)

func main() {
    fmt.Println("Goku CLI - Bookmark Manager")
    // TODO: Implement CLI logic
}
EOF

# Create go.mod file
go mod init github.com/fallrising/goku-cli

# Create README.md
cat << EOF > README.md
# Goku CLI

Goku CLI is a powerful command-line interface application for managing bookmarks, inspired by the open-source project Buku.

## Features

- Fast and efficient bookmark management
- Advanced search capabilities
- Import and export functionality
- Content analysis and similarity search
- Web crawling
- Translation support

## Installation

TODO: Add installation instructions

## Usage

TODO: Add usage instructions

## Contributing

TODO: Add contribution guidelines

## License

TODO: Add license information
EOF

# Create .gitignore
cat << EOF > .gitignore
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with 'go test -c'
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work

# Database files
*.db

# IDE-specific files
.vscode/
.idea/

# OS-specific files
.DS_Store
Thumbs.db
EOF

echo "Goku CLI project structure created successfully!"

```

Contents of go.sum:
```
github.com/cpuguy83/go-md2man/v2 v2.0.4 h1:wfIWP927BUkWJb2NmU/kNDYIBTh/ziUX91+lVfRxZq4=
github.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
github.com/mattn/go-sqlite3 v1.14.23 h1:gbShiuAP1W5j9UOksQ06aiiqPMxYecovVGwmTxWtuw0=
github.com/mattn/go-sqlite3 v1.14.23/go.mod h1:Uh1q+B4BYcTPb+yiD3kU8Ct7aC0hY9fxUwlHK0RXw+Y=
github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/urfave/cli/v2 v2.27.4 h1:o1owoI+02Eb+K107p27wEX9Bb8eqIoZCfLXloLUSWJ8=
github.com/urfave/cli/v2 v2.27.4/go.mod h1:m4QzxcD2qpra4z7WhzEGn74WZLViBnMpb1ToCAKdGRQ=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=
github.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=
golang.org/x/net v0.29.0 h1:5ORfpBpCs4HzDYoodCDBbwHzdR5UrLBZ3sOnUJmFoHo=
golang.org/x/net v0.29.0/go.mod h1:gLkgy8jTGERgjzMic6DS9+SP0ajcu6Xu3Orq/SpETg0=

```

Contents of README.md:
```
# Goku CLI

Goku CLI is a powerful command-line interface application for managing bookmarks, inspired by the open-source project Buku.

## Features

- Fast and efficient bookmark management
- Advanced search capabilities
- Import and export functionality
- Content analysis and similarity search
- Web crawling
- Translation support

## Installation

TODO: Add installation instructions

## Usage

TODO: Add usage instructions

## Contributing

TODO: Add contribution guidelines

## License

TODO: Add license information

```

Contents of build.sh:
```
#!/bin/bash

set -e

# Ensure bin directory exists
mkdir -p bin

echo "Building Goku CLI..."
go build -o bin/goku cmd/goku/main.go

echo "Build completed successfully. Binary is located at bin/goku"
```

Contents of cmd/goku/main.go:
```
package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/fallrising/goku-cli/internal/bookmarks"
	"github.com/fallrising/goku-cli/internal/database"
	"github.com/fallrising/goku-cli/pkg/models"
	"github.com/urfave/cli/v2"
)

func main() {
	dbPath := os.Getenv("GOKU_DB_PATH")
	if dbPath == "" {
		dbPath = "goku.db" // Default to current directory if not specified
	}

	db, err := database.NewDatabase(dbPath)
	if err != nil {
		log.Fatalf("Failed to initialize database: %v", err)
	}

	if err := db.Init(); err != nil {
		log.Fatalf("Failed to initialize database schema: %v", err)
	}

	bookmarkService := bookmarks.NewBookmarkService(db)

	app := &cli.App{
		Name:  "goku",
		Usage: "A powerful CLI bookmark manager",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "db",
				EnvVars: []string{"GOKU_DB_PATH"},
				Value:   "goku.db",
				Usage:   "Path to the Goku database file",
			},
		},
		Commands: []*cli.Command{
			{
				Name:  "add",
				Usage: "Add a new bookmark",
				Flags: []cli.Flag{
					&cli.StringFlag{Name: "url", Required: true},
					&cli.StringFlag{Name: "title"},
					&cli.StringFlag{Name: "description"},
					&cli.StringSliceFlag{Name: "tags"},
				},
				Action: func(c *cli.Context) error {
					bookmark := &models.Bookmark{
						URL:         c.String("url"),
						Title:       c.String("title"),
						Description: c.String("description"),
						Tags:        c.StringSlice("tags"),
					}
					err := bookmarkService.CreateBookmark(context.Background(), bookmark)
					if err != nil {
						return fmt.Errorf("failed to add bookmark: %w", err)
					}
					fmt.Printf("Bookmark added successfully with ID: %d\n", bookmark.ID)
					return nil
				},
			},
			{
				Name:  "get",
				Usage: "Get a bookmark by ID",
				Flags: []cli.Flag{
					&cli.Int64Flag{Name: "id", Required: true},
				},
				Action: func(c *cli.Context) error {
					bookmark, err := bookmarkService.GetBookmark(context.Background(), c.Int64("id"))
					if err != nil {
						return fmt.Errorf("failed to get bookmark: %w", err)
					}
					fmt.Printf("Bookmark: %+v\n", bookmark)
					return nil
				},
			},
			{
				Name:  "update",
				Usage: "Update a bookmark",
				Flags: []cli.Flag{
					&cli.Int64Flag{Name: "id", Required: true},
					&cli.StringFlag{Name: "url"},
					&cli.StringFlag{Name: "title"},
					&cli.StringFlag{Name: "description"},
					&cli.StringSliceFlag{Name: "tags"},
				},
				Action: func(c *cli.Context) error {
					bookmark := &models.Bookmark{
						ID:          c.Int64("id"),
						URL:         c.String("url"),
						Title:       c.String("title"),
						Description: c.String("description"),
						Tags:        c.StringSlice("tags"),
					}
					err := bookmarkService.UpdateBookmark(context.Background(), bookmark)
					if err != nil {
						return fmt.Errorf("failed to update bookmark: %w", err)
					}
					fmt.Println("Bookmark updated successfully")
					return nil
				},
			},
			{
				Name:  "delete",
				Usage: "Delete a bookmark",
				Flags: []cli.Flag{
					&cli.Int64Flag{Name: "id", Required: true},
				},
				Action: func(c *cli.Context) error {
					err := bookmarkService.DeleteBookmark(context.Background(), c.Int64("id"))
					if err != nil {
						return fmt.Errorf("failed to delete bookmark: %w", err)
					}
					fmt.Println("Bookmark deleted successfully")
					return nil
				},
			},
			{
				Name:  "list",
				Usage: "List all bookmarks",
				Action: func(c *cli.Context) error {
					bookmarks, err := bookmarkService.ListBookmarks(context.Background())
					if err != nil {
						return fmt.Errorf("failed to list bookmarks: %w", err)
					}
					for _, b := range bookmarks {
						fmt.Printf("ID: %d, URL: %s, Title: %s, Tags: %v, Description: %v\n", b.ID, b.URL, b.Title, b.Tags, b.Description)
					}
					return nil
				},
			},
			{
				Name:  "search",
				Usage: "Search bookmarks",
				Flags: []cli.Flag{
					&cli.StringFlag{Name: "query", Aliases: []string{"q"}, Required: true},
				},
				Action: func(c *cli.Context) error {
					query := c.String("query")
					bookmarks, err := bookmarkService.SearchBookmarks(context.Background(), query)
					if err != nil {
						return fmt.Errorf("failed to search bookmarks: %w", err)
					}
					if len(bookmarks) == 0 {
						fmt.Println("No bookmarks found matching the query.")
						return nil
					}
					fmt.Printf("Found %d bookmark(s):\n", len(bookmarks))
					for _, b := range bookmarks {
						fmt.Printf("ID: %d, URL: %s, Title: %s, Tags: %v, Description: %v\n", b.ID, b.URL, b.Title, b.Tags, b.Description)
					}
					return nil
				},
			},
		},
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

```

Contents of internal/database/db.go:
```
package database

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/fallrising/goku-cli/pkg/models"
	_ "github.com/mattn/go-sqlite3"
)

type Database struct {
	db *sql.DB
}

func NewDatabase(dbPath string) (*Database, error) {
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return &Database{db: db}, nil
}

func (d *Database) Init() error {
	query := `CREATE TABLE IF NOT EXISTS bookmarks (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		url TEXT NOT NULL,
		title TEXT,
		description TEXT,
		tags TEXT,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
		updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
	)`

	_, err := d.db.Exec(query)
	if err != nil {
		return fmt.Errorf("failed to create bookmarks table: %w", err)
	}

	return nil
}

func (d *Database) Create(ctx context.Context, bookmark *models.Bookmark) error {
	query := `INSERT INTO bookmarks (url, title, description, tags) VALUES (?, ?, ?, ?)`
	tags := strings.Join(bookmark.Tags, ",")

	result, err := d.db.ExecContext(ctx, query, bookmark.URL, bookmark.Title, bookmark.Description, tags)
	if err != nil {
		return fmt.Errorf("failed to insert bookmark: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return fmt.Errorf("failed to get last insert ID: %w", err)
	}

	bookmark.ID = id
	return nil
}

func (d *Database) GetByID(ctx context.Context, id int64) (*models.Bookmark, error) {
	query := `SELECT id, url, title, description, tags, created_at, updated_at FROM bookmarks WHERE id = ?`

	var bookmark models.Bookmark
	var tags string

	err := d.db.QueryRowContext(ctx, query, id).Scan(
		&bookmark.ID, &bookmark.URL, &bookmark.Title, &bookmark.Description,
		&tags, &bookmark.CreatedAt, &bookmark.UpdatedAt,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("bookmark not found")
		}
		return nil, fmt.Errorf("failed to get bookmark: %w", err)
	}

	bookmark.Tags = strings.Split(tags, ",")
	return &bookmark, nil
}

func (d *Database) Update(ctx context.Context, bookmark *models.Bookmark) error {
	query := `UPDATE bookmarks SET url = ?, title = ?, description = ?, tags = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`
	tags := strings.Join(bookmark.Tags, ",")

	_, err := d.db.ExecContext(ctx, query, bookmark.URL, bookmark.Title, bookmark.Description, tags, bookmark.ID)
	if err != nil {
		return fmt.Errorf("failed to update bookmark: %w", err)
	}

	return nil
}

func (d *Database) Delete(ctx context.Context, id int64) error {
	query := `DELETE FROM bookmarks WHERE id = ?`

	_, err := d.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete bookmark: %w", err)
	}

	return nil
}

func (d *Database) List(ctx context.Context) ([]*models.Bookmark, error) {
	query := `SELECT id, url, title, description, tags, created_at, updated_at FROM bookmarks`

	rows, err := d.db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query bookmarks: %w", err)
	}
	defer rows.Close()

	var bookmarks []*models.Bookmark

	for rows.Next() {
		var bookmark models.Bookmark
		var tags string

		err := rows.Scan(
			&bookmark.ID, &bookmark.URL, &bookmark.Title, &bookmark.Description,
			&tags, &bookmark.CreatedAt, &bookmark.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan bookmark row: %w", err)
		}

		bookmark.Tags = strings.Split(tags, ",")
		bookmarks = append(bookmarks, &bookmark)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating bookmark rows: %w", err)
	}

	return bookmarks, nil
}

func (d *Database) Search(ctx context.Context, query string) ([]*models.Bookmark, error) {
	searchQuery := `
		SELECT id, url, title, description, tags, created_at, updated_at 
		FROM bookmarks 
		WHERE url LIKE ? OR title LIKE ? OR description LIKE ? OR tags LIKE ?
	`
	searchParam := "%" + query + "%"

	rows, err := d.db.QueryContext(ctx, searchQuery, searchParam, searchParam, searchParam, searchParam)
	if err != nil {
		return nil, fmt.Errorf("failed to search bookmarks: %w", err)
	}
	defer rows.Close()

	var bookmarks []*models.Bookmark

	for rows.Next() {
		var bookmark models.Bookmark
		var tags string

		err := rows.Scan(
			&bookmark.ID, &bookmark.URL, &bookmark.Title, &bookmark.Description,
			&tags, &bookmark.CreatedAt, &bookmark.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan bookmark row: %w", err)
		}

		bookmark.Tags = strings.Split(tags, ",")
		bookmarks = append(bookmarks, &bookmark)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating bookmark rows: %w", err)
	}

	return bookmarks, nil
}

```

Contents of internal/fetcher/fetcher.go:
```
// internal/fetcher/fetcher.go

package fetcher

import (
	"fmt"
	"net"
	"net/http"
	"net/url"
	"strings"
	"time"

	"golang.org/x/net/html"
)

type PageContent struct {
	Title       string
	Description string
	Tags        []string
}

func FetchPageContent(pageURL string) (*PageContent, error) {
	// Validate URL structure
	parsedURL, err := url.ParseRequestURI(pageURL)
	if err != nil {
		return nil, fmt.Errorf("invalid URL format: %w", err)
	}

	// Check if the URL has a valid host
	if parsedURL.Host == "" {
		return nil, fmt.Errorf("URL must have a valid host")
	}

	// Optionally, check if the hostname can be resolved (basic DNS check)
	_, err = net.LookupHost(parsedURL.Host)
	if err != nil {
		return nil, fmt.Errorf("cannot resolve host: %w", err)
	}

	client := &http.Client{
		Timeout: 10 * time.Second,
	}

	resp, err := client.Get(pageURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch URL: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	doc, err := html.Parse(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to parse HTML: %w", err)
	}

	content := &PageContent{
		Title:       extractTitle(doc),
		Description: extractDescription(doc),
		Tags:        extractTags(doc),
	}

	// If description is empty, try to extract first paragraph
	if content.Description == "" {
		content.Description = extractFirstParagraph(doc)
	}

	return content, nil
}

func extractTitle(n *html.Node) string {
	var title string
	var extractTitleFunc func(*html.Node)
	extractTitleFunc = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "title" && n.FirstChild != nil {
			title = n.FirstChild.Data
			return
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			extractTitleFunc(c)
		}
	}
	extractTitleFunc(n)
	return strings.TrimSpace(title)
}

func extractDescription(n *html.Node) string {
	var description string
	var extractDescFunc func(*html.Node)
	extractDescFunc = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "meta" {
			for _, a := range n.Attr {
				if a.Key == "name" && a.Val == "description" {
					for _, a := range n.Attr {
						if a.Key == "content" {
							description = a.Val
							return
						}
					}
				}
			}
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			extractDescFunc(c)
		}
	}
	extractDescFunc(n)
	return strings.TrimSpace(description)
}

func extractTags(n *html.Node) []string {
	var tags []string
	var extractTagsFunc func(*html.Node)
	extractTagsFunc = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "meta" {
			for _, a := range n.Attr {
				if a.Key == "name" && (a.Val == "keywords" || a.Val == "tags") {
					for _, a := range n.Attr {
						if a.Key == "content" {
							tags = append(tags, strings.Split(a.Val, ",")...)
							return
						}
					}
				}
			}
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			extractTagsFunc(c)
		}
	}
	extractTagsFunc(n)

	// Clean and deduplicate tags
	uniqueTags := make(map[string]bool)
	for _, tag := range tags {
		tag = strings.TrimSpace(strings.ToLower(tag))
		if tag != "" {
			uniqueTags[tag] = true
		}
	}

	var cleanedTags []string
	for tag := range uniqueTags {
		cleanedTags = append(cleanedTags, tag)
	}

	return cleanedTags
}

func extractFirstParagraph(n *html.Node) string {
	var paragraph string
	var extractParagraphFunc func(*html.Node)
	extractParagraphFunc = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "p" {
			paragraph = renderNode(n)
			return
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			extractParagraphFunc(c)
		}
	}
	extractParagraphFunc(n)
	return strings.TrimSpace(paragraph)
}

func renderNode(n *html.Node) string {
	var buf strings.Builder
	renderNodeFunc(&buf, n)
	return buf.String()
}

func renderNodeFunc(w *strings.Builder, n *html.Node) {
	if n.Type == html.TextNode {
		w.WriteString(n.Data)
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		renderNodeFunc(w, c)
	}
}

```

Contents of internal/bookmarks/service.go:
```
package bookmarks

import (
	"context"
	"fmt"
	"github.com/fallrising/goku-cli/internal/fetcher"
	"strings"

	"github.com/fallrising/goku-cli/pkg/interfaces"
	"github.com/fallrising/goku-cli/pkg/models"
)

type BookmarkService struct {
	repo interfaces.BookmarkRepository
}

func NewBookmarkService(repo interfaces.BookmarkRepository) *BookmarkService {
	return &BookmarkService{repo: repo}
}

func (s *BookmarkService) CreateBookmark(ctx context.Context, bookmark *models.Bookmark) error {
	if bookmark.URL == "" {
		return fmt.Errorf("URL is required")
	}

	// Check if URL starts with "http://" or "https://"
	if !(strings.HasPrefix(bookmark.URL, "http://") || strings.HasPrefix(bookmark.URL, "https://")) {
		bookmark.URL = "https://" + bookmark.URL
	}

	// Fetch page content if title, description, or tags are not provided
	if bookmark.Title == "" || bookmark.Description == "" || len(bookmark.Tags) == 0 {
		content, err := fetcher.FetchPageContent(bookmark.URL)
		if err != nil {
			fmt.Printf("Warning: Failed to fetch page content: %v\n", err)
			return err
		} else {
			if bookmark.Title == "" {
				bookmark.Title = content.Title
			}
			if bookmark.Description == "" {
				bookmark.Description = content.Description
			}
			if len(bookmark.Tags) == 0 {
				bookmark.Tags = content.Tags
			}
		}
	}

	return s.repo.Create(ctx, bookmark)
}

func (s *BookmarkService) GetBookmark(ctx context.Context, id int64) (*models.Bookmark, error) {
	return s.repo.GetByID(ctx, id)
}

func (s *BookmarkService) UpdateBookmark(ctx context.Context, updatedBookmark *models.Bookmark) error {
	if updatedBookmark.ID == 0 {
		return fmt.Errorf("bookmark ID is required")
	}

	// Fetch the existing bookmark
	existingBookmark, err := s.repo.GetByID(ctx, updatedBookmark.ID)
	if err != nil {
		return fmt.Errorf("failed to fetch existing bookmark: %w", err)
	}

	// Update only the fields that are provided
	if updatedBookmark.URL != "" {
		existingBookmark.URL = updatedBookmark.URL
	}
	if updatedBookmark.Title != "" {
		existingBookmark.Title = updatedBookmark.Title
	}
	if updatedBookmark.Description != "" {
		existingBookmark.Description = updatedBookmark.Description
	}
	if len(updatedBookmark.Tags) > 0 {
		existingBookmark.Tags = updatedBookmark.Tags
	}

	// Save the updated bookmark
	return s.repo.Update(ctx, existingBookmark)
}

func (s *BookmarkService) DeleteBookmark(ctx context.Context, id int64) error {
	return s.repo.Delete(ctx, id)
}

func (s *BookmarkService) ListBookmarks(ctx context.Context) ([]*models.Bookmark, error) {
	return s.repo.List(ctx)
}

func (s *BookmarkService) SearchBookmarks(ctx context.Context, query string) ([]*models.Bookmark, error) {
	if query == "" {
		return nil, fmt.Errorf("search query cannot be empty")
	}

	return s.repo.Search(ctx, query)
}

```

Contents of docs/PRD.md:
```
# Comprehensive Product Requirements Document: Goku CLI

## 1. Introduction

Goku CLI is a command-line interface application for managing bookmarks, inspired by the open-source project Buku. It aims to provide a powerful, flexible, and user-friendly tool for organizing and searching web bookmarks directly from the terminal, with advanced import capabilities and efficient data management.

## 2. Objectives

- Create a fast and efficient bookmark management system
- Provide a user-friendly CLI interface using the gum library
- Offer advanced features such as content analysis, similarity search, and web crawling
- Ensure data privacy by keeping all data local
- Support multiple import and export formats for easy migration
- Enable high-performance, parallel importing of bookmarks

## 3. Target Users

- Command-line enthusiasts
- Developers and system administrators
- Privacy-conscious internet users
- Users who prefer keyboard-based navigation and management
- Users with large bookmark collections requiring efficient import and management

## 4. Key Features

### 4.1 Bookmark Management
- Add new bookmarks with URL, title, tags, and description
  - Automatically fetch title, tags, and description from the target website
- Update existing bookmarks
- Delete bookmarks
  - Delete a single bookmark
  - Delete a range of bookmarks
  - Delete all bookmarks
- Search bookmarks by various criteria (URL, title, tags, content)
- List and print bookmarks
  - Print all bookmarks
  - Print bookmarks by ID or range
  - Print with specific fields filtered out

### 4.2 Tag Management
- Add tags to bookmarks
- Remove tags from bookmarks
- List all tags
- Search bookmarks by tags
- Suggest similar tags based on existing bookmarks
- Replace existing tags with new tags
- Show a list of unique tags in the database

### 4.3 Import and Export
- Import bookmarks from various formats:
  - HTML (Firefox, Chrome, IE)
  - JSON (Firefox)
  - CSV
  - Markdown
  - Orgfile
  - XBEL
  - RSS feeds
  - Another Goku database
- Export bookmarks to various formats:
  - HTML (Firefox compatible)
  - JSON
  - CSV
  - Markdown
  - Orgfile
  - XBEL
  - RSS feed
  - Another Goku database
- Parallel import capability via dedicated import server
- Auto-import from browsers:
  - Firefox
  - Chrome
  - Chromium
  - Vivaldi
  - Microsoft Edge

### 4.4 Content Analysis
- Automatically fetch and store webpage metadata
- Extract keywords and generate tag suggestions
- Summarize webpage content

### 4.5 Similarity Search
- Find similar bookmarks based on content or metadata

### 4.6 Web Crawling
- Crawl bookmarked pages to extract additional information
- Discover and suggest related links

### 4.7 Translation
- Translate bookmark titles and descriptions
- Support both API-based and local LLM-based translation

### 4.8 Browser Integration
- Open bookmarks in the default browser by ID or range
- Open a random bookmark
- Open a cached version of a bookmark from the Wayback Machine

### 4.9 Database Management
- Use SQLite for local storage in CLI
- Use DuckDB for persistent storage in import server
- Support database merging for synchronization
- Provide database backup and restore functionality

### 4.10 Additional Features
- Encryption/Decryption: Securely encrypt the bookmark database for privacy
- URL Shortening/Expanding: Shorten or expand URLs using the tny.im service
- Clipboard Integration: Copy bookmark URLs to the system clipboard
- Version Checking: Check for the latest upstream release version

## 5. Technical Specifications

### 5.1 Technology Stack
- Primary Programming Language: Go
- Secondary Programming Language: Python (for specific components)
- CLI Interface: gum library (Go)
- CLI Database: SQLite
- Import Server Database: DuckDB
- Testing: Go testing framework and Python unittest
- Required Python libraries:
  - urllib3 for HTTP requests
  - BeautifulSoup for HTML parsing
  - cryptography for encryption (optional)

### 5.2 Application Structure
- Follow a modular architecture (as outlined in the project structure)
- Use interfaces for flexibility and easier testing
- Implement a plugin system for extensibility

### 5.3 Performance Requirements
- Fast search and retrieval (< 100ms for most operations)
- Efficient handling of large numbers of bookmarks (1,000,000+)
- Minimal memory footprint

### 5.4 Security and Privacy
- All data stored locally
- Option for database encryption
- No tracking or data collection

### 5.5 Import Server
- Support HTTP server and Unix domain socket for communication
- Implement parallel processing for high-performance importing
- Use a set data structure to ensure URL uniqueness
- Provide detailed error logging for monitoring and debugging
- Persist import data and state using DuckDB

## 6. User Interface

### 6.1 Command Structure
- `goku add`: Add a new bookmark (with automatic metadata fetching)
- `goku search`: Search bookmarks
- `goku update`: Update a bookmark
- `goku delete`: Delete a bookmark
- `goku export`: Export bookmarks
- `goku import`: Import bookmarks (can use local or server-based import)
- `goku tags`: Manage tags
- `goku similar`: Find similar bookmarks
- `goku crawl`: Crawl a bookmarked page
- `goku server`: Start the import server
- Additional commands for browser integration, encryption, and other features

### 6.2 Interactive Elements
- Use gum for interactive prompts and selections
- Implement autocomplete for tags and URLs
- Provide colorized output for better readability
- Support piped input from other programs

## 7. Data Model

### 7.1 Bookmark
- URL (required, unique)
- Title (automatically fetched)
- Description (automatically fetched)
- Tags (array of strings, partially auto-generated)
- Created timestamp
- Updated timestamp
- Metadata (JSON blob)

## 8. Import Server Specifications

### 8.1 Server Modes
- HTTP server mode
- Unix domain socket mode

### 8.2 Parallel Processing
- Support multiple Goku CLI instances importing simultaneously
- Use goroutines for parallel processing of import requests

### 8.3 Data Management
- Use DuckDB for persistent storage of import data and state
- Implement a set data structure to ensure URL uniqueness across imports

### 8.4 Logging and Monitoring
- Detailed error logging for failed imports
- Performance metrics logging
- Support for external monitoring tools

### 8.5 Debug Mode
- Verbose logging option for debugging
- Endpoint for querying server state and import progress

## 9. Detailed Feature Implementations

### 9.1 Bookmark Management Functions
- `add_rec()`: Adds a new bookmark to the database
- `edit_at_prompt()`: Opens an editor to add a new bookmark
- `update_rec()`: Updates an existing bookmark's URL, title, tags, description, and immutability
- `refreshdb()`: Refreshes the title and description of bookmarks from the web
- `delete_rec()`: Deletes a single bookmark or a range of bookmarks
- `delete_resultset()`: Deletes a set of search results
- `delete_rec_all()`: Deletes all bookmarks from the database
- `cleardb()`: Drops the bookmark table, effectively deleting all bookmarks
- `get_rec_all()`: Retrieves all bookmarks from the database
- `get_rec_by_id()`: Retrieves a bookmark by its ID
- `get_rec_all_by_ids()`: Retrieves multiple bookmarks by their IDs
- `print_rec()`: Prints bookmark details to the console
- `print_rec_with_filter()`: Prints records with specific fields filtered out
- `print_single_rec()`: Prints a single bookmark record

### 9.2 Search Functions
- `searchdb()`: Searches bookmarks by keyword in URL, title, tags, or description
- `search_by_tag()`: Searches for bookmarks with specific tags
- `search_keywords_and_filter_by_tags()`: Combines keyword search with tag filtering
- `exclude_results_from_search()`: Excludes specific keywords from search results

### 9.3 Tag Management Functions
- `append_tag_at_index()`: Appends tags to a bookmark's existing tag set
- `delete_tag_at_index()`: Removes tags from a bookmark's existing tag set
- `get_tag_all()`: Retrieves a list of unique tags and their usage count
- `suggest_similar_tag()`: Suggests similar tags based on existing bookmarks
- `replace_tag()`: Replaces an existing tag with a new tag
- `get_tagstr_from_taglist()`: Constructs a comma-separated string of tags from a list
- `set_tag()`: Appends, overwrites, or removes tags from specific bookmarks
- `show_taglist()`: Displays a list of unique tags in the database

### 9.4 Browser Integration Functions
- `browse_by_index()`: Opens a bookmark in the browser by ID or range
- `browse()`: Opens a URL in the default browser
- `auto_import_from_browser()`: Imports bookmarks from Firefox, Chrome, Vivaldi, and Edge
- `load_chrome_database()`: Imports bookmarks from Chrome's JSON database
- `load_firefox_database()`: Imports bookmarks from Firefox's SQLite database
- `load_edge_database()`: Imports bookmarks from Edge's JSON database
- `browse_cached_url()`: Opens a cached version of a bookmark from the Wayback Machine

### 9.5 Import/Export Functions
- `importdb()`: Imports bookmarks from various file formats
- `mergedb()`: Merges bookmarks from another Goku database file
- `import_md()`: Parses a Markdown file for bookmark data
- `import_org()`: Parses an Orgfile for bookmark data
- `import_rss()`: Parses an RSS feed for bookmark data
- `import_firefox_json()`: Parses a JSON file exported from Firefox for bookmark data
- `import_xbel()`: Parses an XBEL file for bookmark data
- `import_html()`: Parses an HTML file for bookmark data
- `exportdb()`: Exports bookmarks to various file formats
- `convert_bookmark_set()`: Converts bookmark data into various formats for export

### 9.6 Encryption/Decryption Functions
- `GokuCrypt.encrypt_file()`: Encrypts the Goku database file
- `GokuCrypt.decrypt_file()`: Decrypts the Goku database file

### 9.7 URL Management Functions
- `tnyfy_url()`: Shortens or expands a URL using the tny.im service

### 9.8 Clipboard Functions
- `copy_to_clipboard()`: Copies a URL to the system clipboard

### 9.9 Version Management Functions
- `check_upstream_release()`: Checks for the latest upstream release version

## 10. Helper Functions

- `is_bad_url()`: Checks for malformed URLs
- `is_nongeneric_url()`: Identifies non-HTTP and non-generic URLs
- `is_ignored_mime()`: Checks if a URL links to a MIME type that should be skipped during fetching
- `is_unusual_tag()`: Identifies unusual tag strings
- `parse_decoded_page()`: Extracts title, description, and keywords from a decoded HTML page
- `get_data_from_page()`: Detects encoding and extracts data from an HTTP response
- `gen_headers()`: Generates headers for network requests
- `get_PoolManager()`: Creates a pool manager for HTTP requests with proxy support
- `fetch_data()`: Handles server connections and redirects for fetching page data
- `parse_tags()`: Formats and cleanses a list of tags into a comma-separated string
- `prep_tag_search()`: Prepares a list of tags for search and determines the search operator
- `gen_auto_tag()`: Generates a tag in YYYYMonDD format
- `edit_rec()`: Opens an editor to edit a bookmark record
- `to_temp_file_content()`: Generates content for the temporary file used by the editor
- `parse_temp_file_content()`: Parses the content of the temporary file edited by the user
- `get_system_editor()`: Retrieves the default system editor from the environment
- `is_editor_valid()`: Checks for a valid editor string
- `regexp()`: Performs a regular expression search
- `delim_wrap()`: Wraps a string in delimiter characters
- `read_in()`: Handles user input with interrupts disabled
- `sigint_handler()`: Custom handler for SIGINT (Ctrl+C)
- `disable_sigint_handler()`: Disables the custom SIGINT handler
- `enable_sigint_handler()`: Enables the custom SIGINT handler
- `setup_logger()`: Sets up logging with colored output
- `piped_input()`: Handles input piped from another program
- `setcolors()`: Configures color output
- `unwrap()`: Unwraps text by removing line breaks
- `check_stdout_encoding()`: Ensures stdout encoding is UTF-8
- `monkeypatch_textwrap_for_cjk()`: Patches the textwrap module for handling CJK wide characters
- `parse_range()`: Parses a string containing comma-separated indices and ranges
- `get_firefox_profile_names()`: Lists Firefox profiles and detects default profiles

## 11. Future Enhancements

- Implement a TUI (Text User Interface) for a more visual experience
- Add support for bookmark sharing and collaboration
- Integrate with browser extensions for easier bookmarking
- Implement full-text search capabilities
- Add support for bookmark categories or folders
- Develop a distributed version for enterprise use
- Improve user experience with better interactive prompts and feedback
- Implement more sophisticated tag management features, such as tag hierarchies
- Add support for cloud synchronization of bookmarks
- Integrate with other command-line tools and workflows

## 12. Success Metrics

- Number of active users
- User retention rate
- Number of bookmarks managed per user
- Performance metrics (speed of operations, import throughput)
- Community engagement (contributions, issues raised, feature requests)
- User feedback and satisfaction

## 13. Development Roadmap

- Phase 1 (MVP): Core bookmark management features
- Phase 2: Advanced features (content analysis, similarity search)
- Phase 3: Import server implementation and DuckDB integration
- Phase 4: Translation and web crawling capabilities
- Phase 5: Performance optimizations and scaling improvements

## 14. Risks and Mitigations

- Performance issues with large datasets: Implement efficient indexing and caching, leverage DuckDB's performance
- User adoption: Ensure excellent documentation and ease of use
- Data loss: Implement robust backup and restore features
- Privacy concerns: Emphasize local-only storage and optional encryption
- Import server bottlenecks: Implement careful performance monitoring and optimization

This comprehensive PRD combines all the information from both original documents, maintaining the full level of detail and adding structure for easy reference during development. It serves as a complete guide for the Goku CLI project and can be updated as the project evolves.

```

Contents of pkg/models/bookmark.go:
```
package models

import (
	"time"
)

type Bookmark struct {
	ID          int64     `json:"id"`
	URL         string    `json:"url"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Tags        []string  `json:"tags"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (b *Bookmark) AddTag(tag string) {
	for _, t := range b.Tags {
		if t == tag {
			return
		}
	}
	b.Tags = append(b.Tags, tag)
}

func (b *Bookmark) RemoveTag(tag string) {
	for i, t := range b.Tags {
		if t == tag {
			b.Tags = append(b.Tags[:i], b.Tags[i+1:]...)
			return
		}
	}
}

```

Contents of pkg/interfaces/bookmark_repository.go:
```
package interfaces

import (
	"context"

	"github.com/fallrising/goku-cli/pkg/models"
)

type BookmarkRepository interface {
	Create(ctx context.Context, bookmark *models.Bookmark) error
	GetByID(ctx context.Context, id int64) (*models.Bookmark, error)
	Update(ctx context.Context, bookmark *models.Bookmark) error
	Delete(ctx context.Context, id int64) error
	List(ctx context.Context) ([]*models.Bookmark, error)
	Search(ctx context.Context, query string) ([]*models.Bookmark, error)
}

```

